
export default [
  {
    "title": "Velvet Runtime Notes",
    "description": "Use color tokens to keep light and dark themes aligned.",
    "pubDate": "2024-08-05T07:00:00.000Z",
    "content": "Semantic tokens keep your UI stable while the brand evolves.\n\nInstead of hard-coding one-off colors in components, shape a small set of\nvariables and map all surfaces to those variables.\n\n## Why this matters\n\n- You can restyle the app in minutes instead of days\n- Light and dark themes stay behaviorally consistent\n- Add-on pages inherit your visual identity by default\n\n<MdxCallout title=\"MDX Component Demo\">\n  This callout is rendered from JSX inside an MDX post. It is useful for\n  release notes, warnings, and migration tips where you want stronger visual\n  emphasis than plain markdown blocks.\n</MdxCallout>\n\n<MdxMetrics\n  items={[\n    { label: 'Token count', value: '12 core vars' },\n    { label: 'Theme modes', value: 'light + dark + auto' },\n    { label: 'Restyle time', value: '< 30 min' },\n  ]}\n/>\n\n### Token-to-component mapping\n\n| Token | Typical usage |\n| --- | --- |\n| `--surface` | Card backgrounds |\n| `--line` | Borders and separators |\n| `--lagoon-deep` | Links and active nav |\n\nKeep the mapping documented and your team will make fewer ad-hoc styling calls.\n\n### Example: deriving UI from semantic tokens\n\n```tsx\nconst button = {\n  color: 'var(--sea-ink)',\n  background: 'var(--surface)',\n  borderColor: 'var(--line)',\n}\n```\n\nMDX is useful here because you can interleave narrative, tables, code blocks,\nand custom JSX components in one authoring surface.",
    "heroImage": "/images/lagoon-5.svg",
    "_meta": {
      "filePath": "fifth-post.mdx",
      "fileName": "fifth-post.mdx",
      "directory": ".",
      "extension": "mdx",
      "path": "fifth-post"
    },
    "slug": "fifth-post",
    "html": null,
    "mdx": "var Component=(()=>{var m=Object.create;var o=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var f=Object.getOwnPropertyNames;var b=Object.getPrototypeOf,g=Object.prototype.hasOwnProperty;var y=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),v=(t,e)=>{for(var r in e)o(t,r,{get:e[r],enumerable:!0})},l=(t,e,r,i)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of f(e))!g.call(t,a)&&a!==r&&o(t,a,{get:()=>e[a],enumerable:!(i=p(e,a))||i.enumerable});return t};var k=(t,e,r)=>(r=t!=null?m(b(t)):{},l(e||!t||!t.__esModule?o(r,\"default\",{value:t,enumerable:!0}):r,t)),x=t=>l(o({},\"__esModule\",{value:!0}),t);var s=y((_,d)=>{d.exports=_jsx_runtime});var M={};v(M,{default:()=>u});var n=k(s());function c(t){let e={code:\"code\",h2:\"h2\",h3:\"h3\",li:\"li\",p:\"p\",pre:\"pre\",table:\"table\",tbody:\"tbody\",td:\"td\",th:\"th\",thead:\"thead\",tr:\"tr\",ul:\"ul\",...t.components},{MdxCallout:r,MdxMetrics:i}=e;return r||h(\"MdxCallout\",!0),i||h(\"MdxMetrics\",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"Semantic tokens keep your UI stable while the brand evolves.\"}),`\n`,(0,n.jsx)(e.p,{children:`Instead of hard-coding one-off colors in components, shape a small set of\nvariables and map all surfaces to those variables.`}),`\n`,(0,n.jsx)(e.h2,{children:\"Why this matters\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"You can restyle the app in minutes instead of days\"}),`\n`,(0,n.jsx)(e.li,{children:\"Light and dark themes stay behaviorally consistent\"}),`\n`,(0,n.jsx)(e.li,{children:\"Add-on pages inherit your visual identity by default\"}),`\n`]}),`\n`,(0,n.jsx)(r,{title:\"MDX Component Demo\",children:(0,n.jsx)(e.p,{children:`This callout is rendered from JSX inside an MDX post. It is useful for\nrelease notes, warnings, and migration tips where you want stronger visual\nemphasis than plain markdown blocks.`})}),`\n`,(0,n.jsx)(i,{items:[{label:\"Token count\",value:\"12 core vars\"},{label:\"Theme modes\",value:\"light + dark + auto\"},{label:\"Restyle time\",value:\"< 30 min\"}]}),`\n`,(0,n.jsx)(e.h3,{children:\"Token-to-component mapping\"}),`\n`,(0,n.jsxs)(e.table,{children:[(0,n.jsx)(e.thead,{children:(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.th,{children:\"Token\"}),(0,n.jsx)(e.th,{children:\"Typical usage\"})]})}),(0,n.jsxs)(e.tbody,{children:[(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"--surface\"})}),(0,n.jsx)(e.td,{children:\"Card backgrounds\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"--line\"})}),(0,n.jsx)(e.td,{children:\"Borders and separators\"})]}),(0,n.jsxs)(e.tr,{children:[(0,n.jsx)(e.td,{children:(0,n.jsx)(e.code,{children:\"--lagoon-deep\"})}),(0,n.jsx)(e.td,{children:\"Links and active nav\"})]})]})]}),`\n`,(0,n.jsx)(e.p,{children:\"Keep the mapping documented and your team will make fewer ad-hoc styling calls.\"}),`\n`,(0,n.jsx)(e.h3,{children:\"Example: deriving UI from semantic tokens\"}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-tsx\",children:`const button = {\n  color: 'var(--sea-ink)',\n  background: 'var(--surface)',\n  borderColor: 'var(--line)',\n}\n`})}),`\n`,(0,n.jsx)(e.p,{children:`MDX is useful here because you can interleave narrative, tables, code blocks,\nand custom JSX components in one authoring surface.`})]})}function u(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(c,{...t})}):c(t)}function h(t,e){throw new Error(\"Expected \"+(e?\"component\":\"object\")+\" `\"+t+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return x(M);})();\n;return Component;"
  },
  {
    "title": "Neon Mango Protocol",
    "description": "A quick walkthrough of the starter foundations.",
    "pubDate": "2024-07-08T07:00:00.000Z",
    "content": "This starter ships with routes, SSR, and a calm visual system out of the box.\n\nStart by editing route files, then layer in add-ons as needed.\n\n## What you get on day one\n\n- Full-document SSR using TanStack Start\n- Type-safe file routing with generated route types\n- A reusable design token system for light and dark themes\n\nThe goal is simple: let teams ship product pages and APIs without spending the\nfirst week wiring framework internals.\n\n### Suggested order of operations\n\n1. Make the home route feel like your product\n2. Add one feature route and one API route\n3. Introduce add-ons only after your core UX is clear\n\n> Keep the first commit boring. Reliable defaults beat clever setup code.\n\n## Baseline delivery checklist\n\nBefore introducing custom infra, confirm these are green:\n\n- `pnpm dev` starts cleanly\n- one server route returns typed data\n- one API route validates input/output\n- one integration test exercises a full page render\n\nWhen these are in place, you can iterate quickly without losing confidence.\n\n### Example request flow\n\n1. Client navigation enters route loader\n2. Loader calls server function\n3. Server function reads data source and returns typed payload\n4. Route component renders immediately with stable shape\n\nThat flow is simple, predictable, and easy to debug.",
    "heroImage": "/images/lagoon-3.svg",
    "_meta": {
      "filePath": "first-post.md",
      "fileName": "first-post.md",
      "directory": ".",
      "extension": "md",
      "path": "first-post"
    },
    "slug": "first-post",
    "html": "<p>This starter ships with routes, SSR, and a calm visual system out of the box.</p>\n<p>Start by editing route files, then layer in add-ons as needed.</p>\n<h2>What you get on day one</h2>\n<ul>\n<li>Full-document SSR using TanStack Start</li>\n<li>Type-safe file routing with generated route types</li>\n<li>A reusable design token system for light and dark themes</li>\n</ul>\n<p>The goal is simple: let teams ship product pages and APIs without spending the\nfirst week wiring framework internals.</p>\n<h3>Suggested order of operations</h3>\n<ol>\n<li>Make the home route feel like your product</li>\n<li>Add one feature route and one API route</li>\n<li>Introduce add-ons only after your core UX is clear</li>\n</ol>\n<blockquote>\n<p>Keep the first commit boring. Reliable defaults beat clever setup code.</p>\n</blockquote>\n<h2>Baseline delivery checklist</h2>\n<p>Before introducing custom infra, confirm these are green:</p>\n<ul>\n<li><code>pnpm dev</code> starts cleanly</li>\n<li>one server route returns typed data</li>\n<li>one API route validates input/output</li>\n<li>one integration test exercises a full page render</li>\n</ul>\n<p>When these are in place, you can iterate quickly without losing confidence.</p>\n<h3>Example request flow</h3>\n<ol>\n<li>Client navigation enters route loader</li>\n<li>Loader calls server function</li>\n<li>Server function reads data source and returns typed payload</li>\n<li>Route component renders immediately with stable shape</li>\n</ol>\n<p>That flow is simple, predictable, and easy to debug.</p>",
    "mdx": null
  },
  {
    "title": "Static Tide Almanac",
    "description": "Dial in layout polish and image rhythm across cards.",
    "pubDate": "2024-07-29T07:00:00.000Z",
    "content": "As your app grows, visual rhythm matters as much as feature scope.\n\nUse larger feature cards to call attention to primary content, then support with\nsmaller cards for secondary updates.\n\n## Practical layout pattern\n\nUse one featured card followed by standard cards in a responsive grid:\n\n- `lg:col-span-2` for the featured story\n- regular span for supporting posts\n- consistent card media height below `lg`\n\nThat gives you hierarchy without reinventing every breakpoint.\n\n### A quick spacing rule\n\nPair spacing in steps of 4 (`p-4`, `p-8`, `gap-4`, `gap-8`) and only break that\nrule for hero sections.\n\n## Card hierarchy recipe\n\nFor content-heavy indexes, this sequence works well:\n\n1. One featured card with expanded width\n2. Three to six standard cards for breadth\n3. Optional utility card for onboarding links\n\nKeep title sizes mostly consistent and let width + image treatment carry\nhierarchy. That avoids jarring jumps as breakpoints shift.\n\n### Avoiding layout drift\n\nIf cards start to look uneven, check image heights first, then paragraph length.\nConsistency there usually fixes 80% of visual noise.",
    "heroImage": "/images/lagoon-1.svg",
    "_meta": {
      "filePath": "fourth-post.md",
      "fileName": "fourth-post.md",
      "directory": ".",
      "extension": "md",
      "path": "fourth-post"
    },
    "slug": "fourth-post",
    "html": "<p>As your app grows, visual rhythm matters as much as feature scope.</p>\n<p>Use larger feature cards to call attention to primary content, then support with\nsmaller cards for secondary updates.</p>\n<h2>Practical layout pattern</h2>\n<p>Use one featured card followed by standard cards in a responsive grid:</p>\n<ul>\n<li><code>lg:col-span-2</code> for the featured story</li>\n<li>regular span for supporting posts</li>\n<li>consistent card media height below <code>lg</code></li>\n</ul>\n<p>That gives you hierarchy without reinventing every breakpoint.</p>\n<h3>A quick spacing rule</h3>\n<p>Pair spacing in steps of 4 (<code>p-4</code>, <code>p-8</code>, <code>gap-4</code>, <code>gap-8</code>) and only break that\nrule for hero sections.</p>\n<h2>Card hierarchy recipe</h2>\n<p>For content-heavy indexes, this sequence works well:</p>\n<ol>\n<li>One featured card with expanded width</li>\n<li>Three to six standard cards for breadth</li>\n<li>Optional utility card for onboarding links</li>\n</ol>\n<p>Keep title sizes mostly consistent and let width + image treatment carry\nhierarchy. That avoids jarring jumps as breakpoints shift.</p>\n<h3>Avoiding layout drift</h3>\n<p>If cards start to look uneven, check image heights first, then paragraph length.\nConsistency there usually fixes 80% of visual noise.</p>",
    "mdx": null
  },
  {
    "title": "Paper Lantern Cache",
    "description": "How to shape navigation and page structure.",
    "pubDate": "2024-07-15T07:00:00.000Z",
    "content": "Use file-based routes in `src/routes` to grow the app.\n\nKeep shared UI in `src/components` and tune visual tokens in `src/styles.css`.\n\n## Route design tips\n\nTreat routes like product domains, not technical buckets.\n\n- `routes/settings.*` for account surfaces\n- `routes/billing.*` for payment and plan logic\n- `routes/api.*` for server handlers that belong to the same domain\n\nWhen route trees map to business intent, onboarding gets faster and refactors\nhurt less.\n\n```tsx\n// src/routes/billing.index.tsx\nexport const Route = createFileRoute('/billing/')({\n  component: BillingPage,\n})\n```\n\n<MdxMetrics\n  items={[\n    { label: 'Route setup', value: '~10 min' },\n    { label: 'Type safety', value: 'end-to-end' },\n    { label: 'Refactor risk', value: 'lowered' },\n  ]}\n/>\n\n### Collaboration pattern\n\nUse this lightweight ownership split:\n\n1. Product owns route naming and URL intent\n2. Design owns shared layout primitives and tokens\n3. Engineering owns loaders, actions, and caching\n\nThis pattern keeps URL design, data loading, and UI composition in one place.",
    "heroImage": "/images/lagoon-4.svg",
    "_meta": {
      "filePath": "second-post.mdx",
      "fileName": "second-post.mdx",
      "directory": ".",
      "extension": "mdx",
      "path": "second-post"
    },
    "slug": "second-post",
    "html": null,
    "mdx": "var Component=(()=>{var u=Object.create;var r=Object.defineProperty;var p=Object.getOwnPropertyDescriptor;var g=Object.getOwnPropertyNames;var m=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var x=(t,e)=>()=>(e||t((e={exports:{}}).exports,e),e.exports),b=(t,e)=>{for(var i in e)r(t,i,{get:e[i],enumerable:!0})},l=(t,e,i,s)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let o of g(e))!f.call(t,o)&&o!==i&&r(t,o,{get:()=>e[o],enumerable:!(s=p(e,o))||s.enumerable});return t};var w=(t,e,i)=>(i=t!=null?u(m(t)):{},l(e||!t||!t.__esModule?r(i,\"default\",{value:t,enumerable:!0}):i,t)),y=t=>l(r({},\"__esModule\",{value:!0}),t);var d=x((k,c)=>{c.exports=_jsx_runtime});var R={};b(R,{default:()=>h});var n=w(d());function a(t){let e={code:\"code\",h2:\"h2\",h3:\"h3\",li:\"li\",ol:\"ol\",p:\"p\",pre:\"pre\",ul:\"ul\",...t.components},{MdxMetrics:i}=e;return i||M(\"MdxMetrics\",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(e.p,{children:[\"Use file-based routes in \",(0,n.jsx)(e.code,{children:\"src/routes\"}),\" to grow the app.\"]}),`\n`,(0,n.jsxs)(e.p,{children:[\"Keep shared UI in \",(0,n.jsx)(e.code,{children:\"src/components\"}),\" and tune visual tokens in \",(0,n.jsx)(e.code,{children:\"src/styles.css\"}),\".\"]}),`\n`,(0,n.jsx)(e.h2,{children:\"Route design tips\"}),`\n`,(0,n.jsx)(e.p,{children:\"Treat routes like product domains, not technical buckets.\"}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"routes/settings.*\"}),\" for account surfaces\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"routes/billing.*\"}),\" for payment and plan logic\"]}),`\n`,(0,n.jsxs)(e.li,{children:[(0,n.jsx)(e.code,{children:\"routes/api.*\"}),\" for server handlers that belong to the same domain\"]}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:`When route trees map to business intent, onboarding gets faster and refactors\nhurt less.`}),`\n`,(0,n.jsx)(e.pre,{children:(0,n.jsx)(e.code,{className:\"language-tsx\",children:`// src/routes/billing.index.tsx\nexport const Route = createFileRoute('/billing/')({\n  component: BillingPage,\n})\n`})}),`\n`,(0,n.jsx)(i,{items:[{label:\"Route setup\",value:\"~10 min\"},{label:\"Type safety\",value:\"end-to-end\"},{label:\"Refactor risk\",value:\"lowered\"}]}),`\n`,(0,n.jsx)(e.h3,{children:\"Collaboration pattern\"}),`\n`,(0,n.jsx)(e.p,{children:\"Use this lightweight ownership split:\"}),`\n`,(0,n.jsxs)(e.ol,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Product owns route naming and URL intent\"}),`\n`,(0,n.jsx)(e.li,{children:\"Design owns shared layout primitives and tokens\"}),`\n`,(0,n.jsx)(e.li,{children:\"Engineering owns loaders, actions, and caching\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:\"This pattern keeps URL design, data loading, and UI composition in one place.\"})]})}function h(t={}){let{wrapper:e}=t.components||{};return e?(0,n.jsx)(e,{...t,children:(0,n.jsx)(a,{...t})}):a(t)}function M(t,e){throw new Error(\"Expected \"+(e?\"component\":\"object\")+\" `\"+t+\"` to be defined: you likely forgot to import, pass, or provide it.\")}return y(R);})();\n;return Component;"
  },
  {
    "title": "Midnight Compass Build",
    "description": "Where to customize theme and typography.",
    "pubDate": "2024-07-22T07:00:00.000Z",
    "content": "Update CSS variables in `src/styles.css` to fit your brand.\n\nThen adjust header and footer links to match your product.\n\n## Theme alignment checklist\n\nBefore adding one-off colors, audit these variables:\n\n- `--sea-ink` and `--sea-ink-soft` for readable body copy\n- `--surface` and `--surface-strong` for cards and shells\n- `--lagoon` / `--lagoon-deep` for links and active UI affordances\n\nIf those are correct, most components will look coherent with zero extra work.\n\n### Accessibility reminder\n\nCheck contrast on at least three surfaces:\n\n1. page background\n2. primary card\n3. muted card\n\nYou can be highly branded and still hit comfortable readability.\n\n## Typography defaults that travel well\n\nUse a high-contrast display face for headlines and a workhorse sans for body\ncopy. Then lock in a spacing scale that keeps article rhythm consistent:\n\n- headings: `mt-10 mb-3`\n- paragraphs: `mb-5`\n- lists: `mb-6`\n\nWith those defaults set, long-form pages stay readable across both themes.\n\n### Practical review loop\n\nWhen you tweak tokens, review these pages in order:\n\n1. Blog detail page (most typography states)\n2. Blog index page (cards + metadata)\n3. Home page (hero and CTA emphasis)",
    "heroImage": "/images/lagoon-2.svg",
    "_meta": {
      "filePath": "third-post.md",
      "fileName": "third-post.md",
      "directory": ".",
      "extension": "md",
      "path": "third-post"
    },
    "slug": "third-post",
    "html": "<p>Update CSS variables in <code>src/styles.css</code> to fit your brand.</p>\n<p>Then adjust header and footer links to match your product.</p>\n<h2>Theme alignment checklist</h2>\n<p>Before adding one-off colors, audit these variables:</p>\n<ul>\n<li><code>--sea-ink</code> and <code>--sea-ink-soft</code> for readable body copy</li>\n<li><code>--surface</code> and <code>--surface-strong</code> for cards and shells</li>\n<li><code>--lagoon</code> / <code>--lagoon-deep</code> for links and active UI affordances</li>\n</ul>\n<p>If those are correct, most components will look coherent with zero extra work.</p>\n<h3>Accessibility reminder</h3>\n<p>Check contrast on at least three surfaces:</p>\n<ol>\n<li>page background</li>\n<li>primary card</li>\n<li>muted card</li>\n</ol>\n<p>You can be highly branded and still hit comfortable readability.</p>\n<h2>Typography defaults that travel well</h2>\n<p>Use a high-contrast display face for headlines and a workhorse sans for body\ncopy. Then lock in a spacing scale that keeps article rhythm consistent:</p>\n<ul>\n<li>headings: <code>mt-10 mb-3</code></li>\n<li>paragraphs: <code>mb-5</code></li>\n<li>lists: <code>mb-6</code></li>\n</ul>\n<p>With those defaults set, long-form pages stay readable across both themes.</p>\n<h3>Practical review loop</h3>\n<p>When you tweak tokens, review these pages in order:</p>\n<ol>\n<li>Blog detail page (most typography states)</li>\n<li>Blog index page (cards + metadata)</li>\n<li>Home page (hero and CTA emphasis)</li>\n</ol>",
    "mdx": null
  }
]